// Code generated by gsus-db2struct. DO NOT EDIT.
// 订单表
//
//go:generate gsus db2struct orders
package mysql

import "database/sql"

// orders : 订单表
type Orders struct {
	ID          int64          `gorm:"column:id;PRIMARY_KEY;AUTO_INCREMENT;TYPE:bigint;NOT NULL"`                             // 订单ID
	UserID      int64          `gorm:"column:user_id;TYPE:bigint;NOT NULL;INDEX:idx_user_id"`                                 // 用户ID
	OrderNo     string         `gorm:"column:order_no;TYPE:varchar(50);NOT NULL;INDEX:idx_order_no;UNIQUE_INDEX:order_no"`    // 订单号
	TotalAmount float64        `gorm:"column:total_amount;TYPE:decimal(10,2);NOT NULL"`                                       // 总金额
	Status      sql.NullString `gorm:"column:status;TYPE:enum('pending','paid','shipped','completed')" sql:"DEFAULT:pending"` // 订单状态
	CreatedAt   sql.NullTime   `gorm:"column:created_at;TYPE:datetime" sql:"DEFAULT:CURRENT_TIMESTAMP DEFAULT_GENERATED"`     // 创建时间
}

const TableOrders = "orders"

func (o *Orders) TableName() string {
	return TableOrders
}

type OrdersSlice []Orders

func (this OrdersSlice) ForEach(f func(index int, t *Orders)) {
	if len(this) == 0 {
		return
	}
	for i := range this {
		f(i, &this[i])
	}
}

func (this OrdersSlice) Filter(f func(t *Orders) bool) OrdersSlice {
	if len(this) == 0 {
		return nil
	}
	n := make(OrdersSlice, 0, len(this))
	this.ForEach(func(_ int, t *Orders) {
		if f(t) {
			n = append(n, *t)
		}
	})
	return n
}

type OrdersIntMap map[int]*Orders

func (this OrdersIntMap) ForEach(f func(key int, t *Orders)) {
	if len(this) == 0 {
		return
	}
	for k := range this {
		f(k, this[k])
	}
}

func (this OrdersSlice) MapInt(mapFunc func(*Orders) int) (ret []int) {
	if len(this) == 0 {
		return nil
	}
	ret = make([]int, 0, len(this))
	this.ForEach(func(_ int, t *Orders) {
		ret = append(ret, mapFunc(t))
	})
	return ret
}

func (this OrdersSlice) GroupInt(mapFunc func(*Orders) int) (ret map[int]OrdersSlice) {
	if len(this) == 0 {
		return nil
	}
	ret = make(map[int]OrdersSlice)
	this.ForEach(func(_ int, t *Orders) {
		ret[mapFunc(t)] = append(ret[mapFunc(t)], *t)
	})
	return ret
}

func (this OrdersSlice) ToIntMap(indexBy func(t *Orders) int) (m OrdersIntMap) {
	if len(this) == 0 {
		return nil
	}
	m = make(OrdersIntMap)
	this.ForEach(func(_ int, t *Orders) {
		m[indexBy(t)] = t
	})
	return m
}

type OrdersStringMap map[string]*Orders

func (this OrdersStringMap) ForEach(f func(key string, t *Orders)) {
	if len(this) == 0 {
		return
	}
	for k := range this {
		f(k, this[k])
	}
}

func (this OrdersSlice) MapString(mapFunc func(*Orders) string) (ret []string) {
	if len(this) == 0 {
		return nil
	}
	ret = make([]string, 0, len(this))
	this.ForEach(func(_ int, t *Orders) {
		ret = append(ret, mapFunc(t))
	})
	return ret
}

func (this OrdersSlice) GroupString(mapFunc func(*Orders) string) (ret map[string]OrdersSlice) {
	if len(this) == 0 {
		return nil
	}
	ret = make(map[string]OrdersSlice)
	this.ForEach(func(_ int, t *Orders) {
		ret[mapFunc(t)] = append(ret[mapFunc(t)], *t)
	})
	return ret
}

func (this OrdersSlice) ToStringMap(indexBy func(t *Orders) string) (m OrdersStringMap) {
	if len(this) == 0 {
		return nil
	}
	m = make(OrdersStringMap)
	this.ForEach(func(_ int, t *Orders) {
		m[indexBy(t)] = t
	})
	return m
}
